{% load static %}

<style>
    [x-data] {
        .dragging {
            border: 2px dashed var(--primary);
        }

        .has-error {
            border: 2px solid var(--error) !important;
            transition: all 0.3s;
            animation: error-blink 1s ease-in-out;
        }

        @keyframes error-blink {
            0% {
                border-color: red;
            }
            50% {
                border-color: transparent;
            }
            100% {
                border-color: red;
            }
        }

        .file-preview img {
            max-width: 150px;
            height: auto;
            cursor: zoom-in;
        }
    }
</style>

<div class="container mt-4" x-data="fileUpload()">
    <!-- Upload Area -->
    <div class="text-center d-flex flex-column align-items-center rounded p-4 mb-4 bg-transparent"
         @dragover.prevent="handleDragOver"
         @dragleave.prevent="handleDragLeave"
         @drop.prevent="handleDrop"
         :class="{ 'dragging': isDragging, 'has-error': hasError }"
         aria-label="Datei-Upload-Bereich"
    >
        <input
                type="file"
                id="fileInput"
                multiple
                hidden
                @change="handleFileInput"
                accept="{{ accepted_file_types|join:',' }}"
        />

        <div class="upload-icon mb-2">
            <ul class="file-preview list-group mb-3" x-ref="preview"></ul>
            <div class="upload-icon mb-3">
                <i class="bi bi-cloud-arrow-up fs-1 text-primary"></i>
            </div>
            <p class="mb-2">Dateien hier ablegen oder</p>
            <label for="fileInput" class="btn btn-sm btn-primary rounded-pill px-4 position-relative">
                Durchsuchen
            </label>
        </div>

        <div class="mt-4 text-center">
            <p class="mb-2 text-secondary small">UnterstÃ¼tzte Dateiformate (max. 10MB):</p>
            <div class="d-flex justify-content-center gap-3">
                <span class="badge bg-light text-secondary"><i class="bi bi-filetype-pdf me-1"></i>PDF</span>
                <!-- <span class="badge bg-light text-secondary"><i class="bi bi-filetype-doc me-1"></i>DOC</span> -->
                <span class="badge bg-light text-secondary"><i class="bi bi-filetype-jpg me-1"></i>JPG</span>
                <span class="badge bg-light text-secondary"><i class="bi bi-filetype-png me-1"></i>PNG</span>
            </div>
        </div>
    </div>

    <!-- Error Message -->
    <div class="error-message alert alert-danger" x-show="hasError" x-text="errorMessage"></div>

    <!-- Upload Form -->
    <form method="POST" @submit.prevent="handleSubmit">
        {% csrf_token %}
        <button
                type="submit"
                class="btn btn-primary btn-lg"
                x-show="files.length > 0"
                x-cloak
                :disabled="!files.length"
        >
            Hochladen
            <output class="spinner-border spinner-border-sm" role="status" x-show="uploadStatus === 'uploading'"
                    aria-hidden="true" x-cloak></output>
        </button>
    </form>
</div>

<script>
	function fileUpload() {
		const maxFileSize = {{ max_file_size|default:'10485760' }};

		return {
			files: [],
			csrfToken: '{{ csrf_token }}',
			uploadStatus: 'idle',
			isDragging: false,
			hasError: false,
			errorMessage: '',
			acceptedTypes: {{ accepted_file_types|safe|default:"['application/pdf', 'image/jpeg', 'image/png']" }},

			init() {
				this.updateUI();
			},

			handleDragOver() {
				this.isDragging = true;
			},

			handleDragLeave() {
				this.isDragging = false;
			},

			handleDrop(event) {
				this.isDragging = false;
				this.handleFiles(event.dataTransfer.files);
			},

			handleFileInput(event) {
				this.handleFiles(event.target.files);
			},

			validateFile(file) {
				if (!this.acceptedTypes.includes(file.type)) {
					return `UngÃ¼ltiger Dateityp ${file.type}`;
				}
				if (file.size > maxFileSize) {
					return `Datei zu groÃŸ (${(file.size / 1e6).toFixed(1)}MB / Max 10MB)`;
				}
				return true;
			},

			handleFiles(fileList) {
				const errors = [];
				const validFiles = [];

				for (const file of fileList) {
					const result = this.validateFile(file);
					if (typeof result === 'string') {
						errors.push(result);
					} else {
						validFiles.push(file);
					}
				}

				if (validFiles.length) {
					validFiles.forEach(file => this.createPreview(file));
					this.files.push(...validFiles);
					this.updateUI();
				}

				if (errors.length > 0) {
					this.showError(`Folgende Fehler: ${errors.join(' â€¢ ')}`);
				}
			},

			showError(msg) {
				this.errorMessage = msg;
				this.hasError = true;
				setTimeout(() => this.resetError(), 5000);
			},

			resetError() {
				this.errorMessage = '';
				this.hasError = false;
			},

			createPreview(file) {
				const listItem = document.createElement('li');
				listItem.className = 'list-group-item d-flex justify-content-between align-items-center';
				listItem.dataset.filename = file.name;

				const link = document.createElement('a');
				link.className = 'text-decoration-none me-2';
				if (['image/jpeg', 'image/png'].includes(file.type)) {
					link.href = URL.createObjectURL(file);
					link.target = '_blank';
					const img = document.createElement('img');
					img.src = URL.createObjectURL(file);
					img.width = 100;
					link.appendChild(img);
					listItem.appendChild(link);
				} else if (file.type === 'application/pdf') {
					link.textContent = 'ðŸ“„ ' + file.name;
					link.href = URL.createObjectURL(file);
					link.target = '_blank';
					listItem.appendChild(link);
				}

				const removeButton = `<button type="button" class="btn btn-danger btn-sm" @click="removeFile('${file.name}')">Entfernen</button>`
				listItem.innerHTML += removeButton;

				this.$refs.preview.appendChild(listItem);
			},

			removeFile(filename) {
				const newFiles = this.files.filter(file => file.name !== filename);
				const previewItem = document.querySelector(`li[data-filename="${filename}"]`);
				previewItem && previewItem.remove();
				this.files = newFiles;
				this.updateUI();
			},

			updateUI() {
				this.$refs.preview.innerHTML = !this.files.length ? '' : this.$refs.preview.innerHTML;
				this.uploadStatus = this.files.length ? 'ready' : 'idle';
				this.showError = !this.files.length ? false : false;
			},

			async handleSubmit() {
				if (!this.files.length) {
					this.showError('Mindestens eine Datei erforderlich');
					return;
				}

				try {
					this.uploadStatus = 'uploading';

					const formData = new FormData();
					this.files.forEach(file => formData.append('files', file))
					formData.append('csrfmiddlewaretoken', '{{ csrf_token }}')

					const response = await fetch("{% url 'upload_contract' %}", {
						method: 'POST',
						body: formData
					});

					if (response.ok) {
						alert('Upload erfolgreich!');
						this.resetForm();
					} else {
						// Check status code and show error message
						if (response.status === 401) {
							window.location.href = "{% url 'login' %}";
						}
						const error = await response.text();
						this.showError(`Fehler: ${error}`);
					}
				} catch (error) {
					this.showError('Upload fehlgeschlagen. ÃœberprÃ¼fen Sie die Eingabe');
				} finally {
					this.uploadStatus = 'idle';
				}
			},

			resetForm() {
				this.files = [];
				this.$refs.preview.innerHTML = '';
				this.updateUI();
			}
		};
	}
</script>
